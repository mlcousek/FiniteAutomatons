@using FiniteAutomatons.Core.Models.ViewModel
@model FiniteAutomatons.Core.Models.ViewModel.AutomatonViewModel
@{
    ViewData["Title"] = "Automaton Simulator";
}

@if (TempData["ConversionMessage"] != null)
{
    <div class="alert alert-success alert-dismissible fade show">
        <i class="fas fa-check-circle"></i> @TempData["ConversionMessage"]
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>
}

@if (TempData["ErrorMessage"] != null)
{
    <div class="alert alert-danger alert-dismissible fade show">
        <i class="fas fa-exclamation-circle"></i> @TempData["ErrorMessage"]
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>
}

<div class="alert alert-primary">
    <h2>Welcome to the Automaton Simulator!</h2>
    <p>
        This tool allows you to simulate different types of finite automatons step by step.<br />
        <strong>Current Type:</strong> <span class="badge bg-primary">@Model.TypeDisplayName</span><br />
        <strong>How to use:</strong>
        <ul>
            <li>Enter an input string (using the automaton's alphabet) in the input box below.</li>
            <li><strong>Step Forward</strong>: Move the automaton one step forward, processing the next symbol.</li>
            <li><strong>Step Backward</strong>: Move one step back in the input (undo the last step).</li>
            <li><strong>Execute All</strong>: Run the automaton on the entire input string at once.</li>
            <li><strong>Back To Start</strong>: Reset the automaton to the initial state and position.</li>
            <li><strong>Reset</strong>: Clear the automaton and input to start a new simulation.</li>
        </ul>
        @if (Model.Type != AutomatonType.DFA)
        {
            <text><strong>@Model.Type Current States</strong> and <strong>Current Position</strong> are shown below, so you can track the automaton's progress as you step through the input.</text>
        }
        else
        {
            <text><strong>Current State</strong> and <strong>Current Position</strong> are shown below, so you can track the automaton's progress as you step through the input.</text>
        }
        <br />
        The result (Accepted/Rejected) will be displayed after running or stepping through the input.
    </p>
    <div class="mt-3">
        <a asp-controller="Automaton" asp-action="CreateAutomaton" class="btn btn-outline-primary">
            <i class="fas fa-plus"></i> Create Your Own Automaton
        </a>
        <a asp-controller="Automaton" asp-action="GenerateRandomAutomaton" class="btn btn-outline-info ms-2">
            <i class="fas fa-random"></i> Generate Random Automaton
        </a>
        <small class="text-muted ms-2">Or explore the randomly generated automaton below</small>
    </div>
</div>

@if (Model.CurrentStateId != null || (Model.CurrentStates != null && Model.CurrentStates.Any()))
{
    <div class="alert alert-info">
        @if (Model.Type == AutomatonType.DFA)
        {
            <strong>Current State:</strong> @Model.CurrentStateId<br />
        }
        else
        {
            <strong>Current States:</strong> @Model.CurrentStatesDisplay<br />
        }
        <strong>Current Position:</strong> @Model.Position
        @if (!string.IsNullOrEmpty(Model.Input) && Model.Position < Model.Input.Length)
        {
            <span>(Next symbol: '@Model.Input[Model.Position]')</span>
        }
    </div>
}

<!-- Automaton Visualization -->
@if (Model.IsCustomAutomaton)
{
    <div class="alert alert-success">
        <strong><i class="fas fa-user"></i> Custom Automaton</strong> - You are using your own created @Model.TypeDisplayName!
        <a asp-action="CreateAutomaton" class="btn btn-sm btn-outline-success ms-2">Edit Automaton</a>
        @if (Model.Type != AutomatonType.DFA)
        {
            <form asp-controller="Automaton" asp-action="ConvertToDFA" method="post" class="d-inline ms-2">
                <!-- Include all model data for conversion -->
                @for (int i = 0; i < Model.States.Count; i++)
                {
                    <input type="hidden" name="States[@i].Id" value="@Model.States[i].Id" />
                    <input type="hidden" name="States[@i].IsStart" value="@(Model.States[i].IsStart.ToString().ToLower())" />
                    <input type="hidden" name="States[@i].IsAccepting" value="@(Model.States[i].IsAccepting.ToString().ToLower())" />
                }
                @for (int i = 0; i < Model.Transitions.Count; i++)
                {
                    <input type="hidden" name="Transitions[@i].FromStateId" value="@Model.Transitions[i].FromStateId" />
                    <input type="hidden" name="Transitions[@i].ToStateId" value="@Model.Transitions[i].ToStateId" />
                    <input type="hidden" name="Transitions[@i].Symbol" value="@Model.Transitions[i].Symbol" />
                }
                <input type="hidden" name="Type" value="@Model.Type" />
                <input type="hidden" name="Input" value="@Model.Input" />
                <input type="hidden" name="IsCustomAutomaton" value="@Model.IsCustomAutomaton.ToString().ToLower()" />
                <button type="submit" class="btn btn-sm btn-outline-primary" title="Convert to DFA">
                    <i class="fas fa-exchange-alt"></i> Convert to DFA
                </button>
            </form>
        }
    </div>
}
else
{
    <div class="alert alert-info">
        <strong><i class="fas fa-random"></i> Randomly Generated Automaton</strong> - This is a randomly generated @Model.TypeDisplayName with @Model.States.Count states and @Model.Alphabet.Count-letter alphabet. 
        <small class="d-block mt-1">Refresh the page to get a different random automaton!</small>
    </div>
}

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-circle"></i> States</h5>
            </div>
            <div class="card-body">
                @foreach (var state in Model.States)
                {
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span>
                            <strong>State @state.Id</strong>
                            @if (state.IsStart) { <span class="badge bg-primary">Start</span> }
                            @if (state.IsAccepting) { <span class="badge bg-success">Accept</span> }
                            @if (Model.Type == AutomatonType.DFA && Model.CurrentStateId == state.Id)
                            {
                                <span class="badge bg-warning">Current</span>
                            }
                            @if (Model.Type != AutomatonType.DFA && Model.CurrentStates != null && Model.CurrentStates.Contains(state.Id))
                            {
                                <span class="badge bg-warning">Current</span>
                            }
                        </span>
                    </div>
                }
            </div>
        </div>
    </div>

    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-font"></i> Alphabet</h5>
            </div>
            <div class="card-body">
                @foreach (var symbol in Model.Alphabet)
                {
                    <span class="badge bg-info me-2 mb-1">@symbol</span>
                }
                @if (Model.SupportsEpsilonTransitions && Model.Transitions.Any(t => t.Symbol == '\0'))
                {
                    <span class="badge bg-secondary me-2 mb-1">ε</span>
                }
            </div>
        </div>
    </div>

    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-arrow-right"></i> Transitions</h5>
            </div>
            <div class="card-body" style="max-height: 200px; overflow-y: auto;">
                @foreach (var t in Model.Transitions)
                {
                    <div class="small mb-1">
                        <code>@t.FromStateId --@(t.Symbol == '\0' ? "ε" : t.Symbol.ToString())--> @t.ToStateId</code>
                    </div>
                }
            </div>
        </div>
    </div>
</div>

<div class="card mt-3">
    <div class="card-header">
        <h5><i class="fas fa-play"></i> Simulation Controls</h5>
    </div>
    <div class="card-body">
        <form id="automatonForm" asp-controller="Automaton" asp-action="SimulateAutomaton" method="post">
            <div class="mb-3">
                <label for="inputString" class="form-label">Input String</label>
                @{
                    // Disable input field when execution has started
                    bool isInputDisabled = Model.Position > 0 || Model.Result != null ||
                                         (Model.Type == AutomatonType.DFA && Model.CurrentStateId != null) ||
                                         (Model.Type != AutomatonType.DFA && Model.CurrentStates != null && Model.CurrentStates.Any());
                }
                <input type="text" class="form-control @(isInputDisabled ? "disabled" : "")" id="inputString" name="Input" value="@Model.Input" 
                       placeholder="@(isInputDisabled ? "Input locked during execution - click Reset to enter new input" : "Enter a string using the alphabet above...")"
                       @(isInputDisabled ? "disabled readonly" : "") />
                @if (isInputDisabled)
                {
                    <small class="text-muted mt-1 d-block">
                        <i class="fas fa-lock"></i> Input is locked during execution. Click <strong>Reset</strong> to enter a new word.
                    </small>
                }
            </div>
            
            @for (int i = 0; i < Model.States.Count; i++)
            {
                <input type="hidden" name="States[@i].Id" value="@Model.States[i].Id" />
                <input type="hidden" name="States[@i].IsStart" value="@(Model.States[i].IsStart.ToString().ToLower())" />
                <input type="hidden" name="States[@i].IsAccepting" value="@(Model.States[i].IsAccepting.ToString().ToLower())" />
            }
            @for (int i = 0; i < Model.Transitions.Count; i++)
            {
                <input type="hidden" name="Transitions[@i].FromStateId" value="@Model.Transitions[i].FromStateId" />
                <input type="hidden" name="Transitions[@i].ToStateId" value="@Model.Transitions[i].ToStateId" />
                <input type="hidden" name="Transitions[@i].Symbol" value="@Model.Transitions[i].Symbol" />
            }
            <!-- Automaton execution state round-trip -->
            <input type="hidden" name="Type" value="@Model.Type" />
            <input type="hidden" name="CurrentStateId" value="@Model.CurrentStateId" />
            @if (Model.CurrentStates != null)
            {
                @for (int i = 0; i < Model.CurrentStates.Count; i++)
                {
                    <input type="hidden" name="CurrentStates[@i]" value="@Model.CurrentStates.ElementAt(i)" />
                }
            }
            <input type="hidden" name="Position" value="@Model.Position" />
            <input type="hidden" name="IsAccepted" value="@Model.IsAccepted" />
            <input type="hidden" name="StateHistorySerialized" value="@Model.StateHistorySerialized" />
            <input type="hidden" name="IsCustomAutomaton" value="@Model.IsCustomAutomaton.ToString().ToLower()" />
            
            <div class="btn-group" role="group">
                @{
                    // Comprehensive button state logic with input validation
                    bool hasInput = !string.IsNullOrEmpty(Model.Input);
                    bool isAtFirstPosition = Model.Position == 0;
                    bool isAtEnd = hasInput && Model.Position >= Model.Input.Length;
                    bool hasExecutionStarted = Model.Position > 0 || Model.Result != null ||
                                             (Model.Type == AutomatonType.DFA && Model.CurrentStateId != null) ||
                                             (Model.Type != AutomatonType.DFA && Model.CurrentStates != null && Model.CurrentStates.Any());
                    
                    // Check if input is valid against alphabet (server-side validation)
                    bool isInputValid = true;
                    if (hasInput && Model.Alphabet != null && Model.Alphabet.Any())
                    {
                        isInputValid = Model.Input.All(c => Model.Alphabet.Contains(c));
                    }
                    
                    // Button state calculations based on your requirements:
                    
                    // 1. Step Forward & Execute All: Active when input is valid, present and not at end
                    bool canStepForward = hasInput && isInputValid && !isAtEnd && Model.Result != false;
                    bool canExecuteAll = hasInput && isInputValid && !isAtEnd && Model.Result != false;
                    
                    // 2. Step Backward: Active when not at first position (position > 0)
                    bool canStepBackward = !isAtFirstPosition && isInputValid;
                    
                    // 3. Back To Start: Active when execution has started and input is valid
                    bool canBackToStart = hasExecutionStarted && isInputValid;
                    
                    // 4. Reset: Active when execution has started (not just when input is present)
                    bool canReset = hasExecutionStarted;
                }
                
                <button type="submit" class="btn btn-primary @(!canStepForward ? "disabled" : "")" 
                        formaction="/Automaton/StepForward" @(!canStepForward ? "disabled" : "")
                        title="@(!canStepForward ? (!hasInput ? "Enter input to start stepping" : !isInputValid ? "Input contains invalid characters" : "Already at end of input") : "Process next symbol")">
                    <i class="fas fa-step-forward"></i> Step Forward
                </button>
                <button type="submit" class="btn btn-secondary @(!canStepBackward ? "disabled" : "")" 
                        formaction="/Automaton/StepBackward" @(!canStepBackward ? "disabled" : "")
                        title="@(!canStepBackward ? (!isInputValid ? "Input contains invalid characters" : "Already at first position") : "Undo last step")">
                    <i class="fas fa-step-backward"></i> Step Backward
                </button>
                <button type="submit" class="btn btn-success @(!canExecuteAll ? "disabled" : "")" 
                        formaction="/Automaton/ExecuteAll" @(!canExecuteAll ? "disabled" : "")
                        title="@(!canExecuteAll ? (!hasInput ? "Enter input to execute" : !isInputValid ? "Input contains invalid characters" : "Already at end of input") : "Run entire input at once")">
                    <i class="fas fa-play"></i> Execute All
                </button>
                <button type="submit" class="btn btn-warning @(!canBackToStart ? "disabled" : "")" 
                        formaction="/Automaton/BackToStart" @(!canBackToStart ? "disabled" : "")
                        title="@(!canBackToStart ? (!isInputValid ? "Input contains invalid characters" : "Already at start position") : "Reset to beginning of input")">
                    <i class="fas fa-home"></i> Back To Start
                </button>
                <button type="submit" class="btn btn-danger @(!canReset ? "disabled" : "")" 
                        formaction="/Automaton/Reset" @(!canReset ? "disabled" : "")
                        title="@(!canReset ? "Start execution to enable reset" : "Clear input and reset execution state")">
                    <i class="fas fa-refresh"></i> Reset
                </button>
            </div>
        </form>
    </div>
</div>

@if (Model.Result != null)
{
    <div class="alert @(Model.Result.Value ? "alert-success" : "alert-danger") mt-3">
        <strong>Result:</strong> 
        <i class="fas @(Model.Result.Value ? "fa-check-circle" : "fa-times-circle")"></i>
        @(Model.Result.Value ? "Accepted" : "Rejected")
        @if (Model.Type != AutomatonType.DFA && Model.CurrentStates != null && Model.CurrentStates.Any())
        {
            <small class="d-block mt-1">Final states: @Model.CurrentStatesDisplay</small>
        }
    </div>
}

@section Scripts {
    <style>
        /* Custom styling for disabled input during execution */
        .form-control.disabled {
            background-color: #f8f9fa;
            color: #6c757d;
            border-color: #dee2e6;
            cursor: not-allowed;
        }
        
        .input-lock-message {
            border-left: 3px solid #ffc107;
            padding-left: 8px;
            margin-top: 5px;
        }
        
        .input-lock-message i {
            color: #ffc107;
        }
    </style>
    
    <script>
        // Auto-validate input against alphabet and update button states
        document.getElementById('inputString').addEventListener('input', function() {
            const alphabet = [@Html.Raw(string.Join(",", Model.Alphabet.Select(c => $"'{c}'")))];
            const supportsEpsilon = @(Model.SupportsEpsilonTransitions.ToString().ToLower());
            const input = this.value;
            let isValid = true;
            
            // Only validate if input field is not disabled
            if (!this.disabled) {
                // Validate input against alphabet
                for (let char of input) {
                    if (!alphabet.includes(char)) {
                        isValid = false;
                        break;
                    }
                }
                
                // Update input field visual state
                this.className = isValid ? 'form-control is-valid' : 'form-control is-invalid';
                
                // Update button states dynamically based on input validity
                updateButtonStates(input, isValid);
            }
        });

        function updateButtonStates(inputValue, isInputValid) {
            const hasInput = inputValue && inputValue.length > 0;
            const position = @Model.Position;
            const hasExecutionStarted = position > 0 || @(Model.Result != null ? "true" : "false") || 
                                      @(Model.CurrentStateId != null ? "true" : "false") ||
                                      (@(Model.CurrentStates != null && Model.CurrentStates.Any() ? "true" : "false"));
            const isAtEnd = hasInput && position >= inputValue.length;
            
            // Get button references
            const stepForwardBtn = document.querySelector('button[formaction="/Automaton/StepForward"]');
            const stepBackwardBtn = document.querySelector('button[formaction="/Automaton/StepBackward"]');
            const executeAllBtn = document.querySelector('button[formaction="/Automaton/ExecuteAll"]');
            const backToStartBtn = document.querySelector('button[formaction="/Automaton/BackToStart"]');
            const resetBtn = document.querySelector('button[formaction="/Automaton/Reset"]');
            const inputField = document.getElementById('inputString');
            
            // Calculate button states based on new logic
            const canStepForward = hasInput && isInputValid && !isAtEnd;
            const canExecuteAll = hasInput && isInputValid && !isAtEnd;
            const canStepBackward = position > 0 && isInputValid;
            const canBackToStart = hasExecutionStarted && isInputValid;
            const canReset = hasExecutionStarted; // Only when execution started, not just input present
            
            // Update input field state - disable when execution has started
            updateInputField(inputField, hasExecutionStarted);
            
            // Update Step Forward
            updateButton(stepForwardBtn, canStepForward, {
                enabled: 'Process next symbol',
                disabled: !hasInput ? 'Enter input to start stepping' : 
                         !isInputValid ? 'Input contains invalid characters' : 
                         'Already at end of input'
            });
            
            // Update Step Backward
            updateButton(stepBackwardBtn, canStepBackward, {
                enabled: 'Undo last step',
                disabled: !isInputValid ? 'Input contains invalid characters' : 
                         'Already at first position'
            });
            
            // Update Execute All
            updateButton(executeAllBtn, canExecuteAll, {
                enabled: 'Run entire input at once',
                disabled: !hasInput ? 'Enter input to execute' : 
                         !isInputValid ? 'Input contains invalid characters' : 
                         'Already at end of input'
            });
            
            // Update Back To Start
            updateButton(backToStartBtn, canBackToStart, {
                enabled: 'Reset to beginning of input',
                disabled: !isInputValid ? 'Input contains invalid characters' : 
                         'Already at start position'
            });
            
            // Update Reset - Only enabled after execution starts
            updateButton(resetBtn, canReset, {
                enabled: 'Clear input and reset execution state',
                disabled: 'Start execution to enable reset'
            });
        }
        
        function updateButton(button, canPerformAction, tooltips) {
            if (canPerformAction) {
                button.classList.remove('disabled');
                button.removeAttribute('disabled');
                button.title = tooltips.enabled;
            } else {
                button.classList.add('disabled');
                button.setAttribute('disabled', 'disabled');
                button.title = tooltips.disabled;
            }
        }

        function updateInputField(inputField, hasExecutionStarted) {
            if (hasExecutionStarted) {
                // Disable input field during execution
                inputField.setAttribute('disabled', 'disabled');
                inputField.setAttribute('readonly', 'readonly');
                inputField.classList.add('disabled');
                inputField.placeholder = 'Input locked during execution - click Reset to enter new input';
                
                // Show lock message if not already present
                let lockMessage = inputField.parentElement.querySelector('.input-lock-message');
                if (!lockMessage) {
                    lockMessage = document.createElement('small');
                    lockMessage.className = 'text-muted mt-1 d-block input-lock-message';
                    lockMessage.innerHTML = '<i class="fas fa-lock"></i> Input is locked during execution. Click <strong>Reset</strong> to enter a new word.';
                    inputField.parentElement.appendChild(lockMessage);
                }
            } else {
                // Enable input field when no execution
                inputField.removeAttribute('disabled');
                inputField.removeAttribute('readonly');
                inputField.classList.remove('disabled');
                inputField.placeholder = 'Enter a string using the alphabet above...';
                
                // Remove lock message
                let lockMessage = inputField.parentElement.querySelector('.input-lock-message');
                if (lockMessage) {
                    lockMessage.remove();
                }
            }
        }

        // Initialize button and input states on page load
        document.addEventListener('DOMContentLoaded', function() {
            const inputField = document.getElementById('inputString');
            const alphabet = [@Html.Raw(string.Join(",", Model.Alphabet.Select(c => $"'{c}'")))];
            const input = inputField.value;
            let isValid = true;
            
            // Validate current input if field is not disabled
            if (!inputField.disabled) {
                for (let char of input) {
                    if (!alphabet.includes(char)) {
                        isValid = false;
                        break;
                    }
                }
                
                // Set initial input field state
                inputField.className = isValid ? 'form-control is-valid' : 'form-control is-invalid';
            }
            
            // Initialize button states
            updateButtonStates(input, isValid);
        });
    </script>
}

