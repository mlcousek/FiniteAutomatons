@using FiniteAutomatons.Core.Models.ViewModel
@model FiniteAutomatons.Core.Models.ViewModel.AutomatonViewModel
@{
    ViewData["Title"] = "Automaton Simulator";
}

@if (TempData["ConversionMessage"] != null)
{
    <div class="alert alert-success alert-dismissible fade show">
        <i class="fas fa-check-circle"></i> @TempData["ConversionMessage"]
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>
}

@if (TempData["ErrorMessage"] != null)
{
    <div class="alert alert-danger alert-dismissible fade show">
        <i class="fas fa-exclamation-circle"></i> @TempData["ErrorMessage"]
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>
}

<div class="alert alert-primary">
    <h2>Welcome to the Automaton Simulator!</h2>
    <p>
        This tool allows you to simulate different types of finite automatons step by step.<br />
        <strong>Current Type:</strong> <span class="badge bg-primary">@Model.TypeDisplayName</span><br />
        <strong>How to use:</strong>
        <ul>
            <li>Enter an input string (using the automaton's alphabet) in the input box below.</li>
            <li><strong>Step Forward</strong>: Move the automaton one step forward, processing the next symbol.</li>
            <li><strong>Step Backward</strong>: Move one step back in the input (undo the last step).</li>
            <li><strong>Execute All</strong>: Run the automaton on the entire input string at once.</li>
            <li><strong>Back To Start</strong>: Reset the automaton to the initial state and position.</li>
            <li><strong>Reset</strong>: Clear the automaton and input to start a new simulation.</li>
        </ul>
        @if (Model.Type != AutomatonType.DFA)
        {
            <text><strong>@Model.Type Current States</strong> and <strong>Current Position</strong> are shown below, so you can track the automaton's progress as you step through the input.</text>
        }
        else
        {
            <text><strong>Current State</strong> and <strong>Current Position</strong> are shown below, so you can track the automaton's progress as you step through the input.</text>
        }
        <br />
        The result (Accepted/Rejected) will be displayed after running or stepping through the input.
    </p>
    <div class="mt-3">
        <a asp-controller="Automaton" asp-action="CreateAutomaton" class="btn btn-outline-primary">
            <i class="fas fa-plus"></i> Create Your Own Automaton
        </a>
        <a asp-controller="Automaton" asp-action="GenerateRandomAutomaton" class="btn btn-outline-info ms-2">
            <i class="fas fa-random"></i> Generate Random Automaton
        </a>
        <small class="text-muted ms-2">Or explore the randomly generated automaton below</small>
    </div>
</div>

@if (Model.CurrentStateId != null || (Model.CurrentStates != null && Model.CurrentStates.Any()))
{
    <div class="alert alert-info border-start border-4 border-info">
        <div class="d-flex align-items-center">
            <i class="fas fa-info-circle me-2"></i>
            <div>
                @if (Model.Type == AutomatonType.DFA)
                {
                    <strong>Current State:</strong> @Model.CurrentStateId <span class="badge bg-primary fs-6">State @Model.CurrentStateId</span><br />
                }
                else
                {
                    <strong>Current States:</strong>
                    @if (Model.CurrentStates != null && Model.CurrentStates.Any())
                    {
                        @foreach (var stateId in Model.CurrentStates)
                        {
                            @stateId <span class="badge bg-primary fs-6 me-1">State @stateId</span>
                        }
                    }
                    <br />
                }
                <strong>Current Position:</strong> @Model.Position <span class="badge bg-secondary fs-6">@Model.Position</span>
                @if (!string.IsNullOrEmpty(Model.Input))
                {
                    <span class="text-muted">/ @Model.Input.Length</span>
                    @if (Model.Position < Model.Input.Length)
                    {
                        <span class="ms-2">
                            <i class="fas fa-arrow-right text-warning"></i>
                            Next symbol: <code class="bg-warning text-dark px-1 rounded">'@Model.Input[Model.Position]'</code>
                        </span>
                    }
                    else if (Model.Position >= Model.Input.Length)
                    {
                        <span class="ms-2 text-info">
                            <i class="fas fa-flag-checkered"></i>
                            Input processing complete
                        </span>
                    }
                }
                else
                {
                    <span class="ms-2 text-muted">
                        <i class="fas fa-info"></i>
                        Empty string input
                    </span>
                }
            </div>
        </div>
    </div>
}

<!-- Automaton Visualization -->
@if (Model.IsCustomAutomaton)
{
    <div class="alert alert-success">
        <strong><i class="fas fa-user"></i> Custom Automaton</strong> - You are using your own created @Model.TypeDisplayName!
        <a asp-action="CreateAutomaton" class="btn btn-sm btn-outline-success ms-2">Edit Automaton</a>
        @if (Model.Type != AutomatonType.DFA)
        {
            <form asp-controller="Automaton" asp-action="ConvertToDFA" method="post" class="d-inline ms-2">
                <!-- Include all model data for conversion -->
                @for (int i = 0; i < Model.States.Count; i++)
                {
                    <input type="hidden" name="States[@i].Id" value="@Model.States[i].Id" />
                    <input type="hidden" name="States[@i].IsStart" value="@(Model.States[i].IsStart.ToString().ToLower())" />
                    <input type="hidden" name="States[@i].IsAccepting" value="@(Model.States[i].IsAccepting.ToString().ToLower())" />
                }
                @for (int i = 0; i < Model.Transitions.Count; i++)
                {
                    <input type="hidden" name="Transitions[@i].FromStateId" value="@Model.Transitions[i].FromStateId" />
                    <input type="hidden" name="Transitions[@i].ToStateId" value="@Model.Transitions[i].ToStateId" />
                    <input type="hidden" name="Transitions[@i].Symbol" value="@(Model.Transitions[i].Symbol == '\0' ? "ε" : Model.Transitions[i].Symbol.ToString())" />
                }
                <input type="hidden" name="Type" value="@Model.Type" />
                <input type="hidden" name="Input" value="@Model.Input" />
                <input type="hidden" name="IsCustomAutomaton" value="@Model.IsCustomAutomaton.ToString().ToLower()" />
                <button type="submit" class="btn btn-sm btn-outline-primary" title="Convert to DFA">
                    <i class="fas fa-exchange-alt"></i> Convert to DFA
                </button>
            </form>
        }
    </div>
}
else
{
    <div class="alert alert-info">
        <strong><i class="fas fa-random"></i> Randomly Generated Automaton</strong> - This is a randomly generated @Model.TypeDisplayName with @Model.States.Count states and @Model.Alphabet.Count-letter alphabet. 
        <small class="d-block mt-1">Refresh the page to get a different random automaton!</small>
    </div>
}

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-circle"></i> States</h5>
            </div>
            <div class="card-body">
                @foreach (var state in Model.States)
                {
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span>
                            <strong>State @state.Id</strong>
                            @if (state.IsStart) { <span class="badge bg-primary">Start</span> }
                            @if (state.IsAccepting) { <span class="badge bg-success">Accept</span> }
                            @if (Model.Type == AutomatonType.DFA && Model.CurrentStateId == state.Id)
                            {
                                <span class="badge bg-warning">Current</span>
                            }
                            @if (Model.Type != AutomatonType.DFA && Model.CurrentStates != null && Model.CurrentStates.Contains(state.Id))
                            {
                                <span class="badge bg-warning">Current</span>
                            }
                        </span>
                    </div>
                }
            </div>
        </div>
    </div>

    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-font"></i> Alphabet</h5>
            </div>
            <div class="card-body">
                @foreach (var symbol in Model.Alphabet)
                {
                    @if (symbol == 'ε')
                    {
                        <span class="badge bg-secondary me-2 mb-1">ε</span>
                    }
                    else
                    {
                        <span class="badge bg-info me-2 mb-1">@symbol</span>
                    }
                }
                @if (Model.SupportsEpsilonTransitions && Model.Transitions.Any(t => t.Symbol == '\0'))
                {
                    <span class="badge bg-secondary me-2 mb-1">ε</span>
                }
            </div>
        </div>
    </div>

    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-arrow-right"></i> Transitions</h5>
            </div>
            <div class="card-body" style="max-height: 200px; overflow-y: auto;">
                @foreach (var t in Model.Transitions)
                {
                    <div class="small mb-1">
                        <code>@t.FromStateId --@(t.Symbol == '\0' ? "ε" : t.Symbol.ToString())--> @t.ToStateId</code>
                    </div>
                }
            </div>
        </div>
    </div>
</div>

<div class="card mt-3">
    <div class="card-header">
        <h5><i class="fas fa-play"></i> Simulation Controls</h5>
    </div>
    <div class="card-body">
        <form id="automatonForm" asp-controller="Automaton" asp-action="SimulateAutomaton" method="post">
            <div class="mb-3">
                <label for="inputString" class="form-label">Input String</label>
                @{
                    // Execution considered started only after at least one step (Position>0) or a Result was produced
                    bool executionStarted = Model.HasExecuted || Model.Result != null || (Model.Type != AutomatonType.DFA && Model.CurrentStates != null && Model.CurrentStates.Any());
                    bool isInputDisabled = executionStarted; // lock only after actual progress

                    // Only keep usable alphabet symbols server-side for any future needs
                    var alphabetList = Model.Alphabet ?? new List<char>();
                    var usableSymbols = alphabetList.Where(c => c != 'ε').ToList();
                }

                <div class="mb-2">
                    <label class="form-label">Quick actions</label>
                    <div>
                        <button type="button" id="randomSuggestion" class="btn btn-outline-info" title="Generate random string">Generate Random</button>
                        <button type="button" id="generateAccepting" class="btn btn-outline-success ms-2" title="Generate accepting string">Generate Accepting</button>
                        <small class="text-muted ms-2">Generate random or an accepting string from the automaton (length limit applied).</small>
                    </div>
                </div>

                <input type="text" class="form-control @(isInputDisabled ? "disabled" : "")" id="inputString" name="Input" value="@Model.Input" 
                       placeholder="@(isInputDisabled ? "Input locked during execution - click Reset to enter new input" : "Enter a string using the alphabet above...")"
                       @(isInputDisabled ? "readonly" : "") />

                <!-- Input visualization: per-character badges with highlights for processed/current/EOF -->
                <div id="inputVisualization" class="mt-2 input-visualization p-2" aria-live="polite">
                    @if (!string.IsNullOrEmpty(Model.Input))
                    {
                        for (int i = 0; i < Model.Input.Length; i++)
                        {
                            var ch = Model.Input[i];
                            var cls = i < Model.Position ? "input-highlight-processed" : (i == Model.Position ? "input-highlight-current" : "");
                            <span class="@cls">@ch</span>
                        }

                        if (Model.Position >= Model.Input.Length)
                        {
                            <span class="input-highlight-eof">▮</span>
                        }
                    }
                    else
                    {
                        <small class="text-muted">No input provided</small>
                    }
                </div>
            </div>
            
            @for (int i = 0; i < Model.States.Count; i++)
            {
                <input type="hidden" name="States[@i].Id" value="@Model.States[i].Id" />
                <input type="hidden" name="States[@i].IsStart" value="@(Model.States[i].IsStart.ToString().ToLower())" />
                <input type="hidden" name="States[@i].IsAccepting" value="@(Model.States[i].IsAccepting.ToString().ToLower())" />
            }
            @for (int i = 0; i < Model.Transitions.Count; i++)
            {
                <input type="hidden" name="Transitions[@i].FromStateId" value="@Model.Transitions[i].FromStateId" />
                <input type="hidden" name="Transitions[@i].ToStateId" value="@Model.Transitions[i].ToStateId" />
                <input type="hidden" name="Transitions[@i].Symbol" value="@(Model.Transitions[i].Symbol == '\0' ? "ε" : Model.Transitions[i].Symbol.ToString())" />
            }
            <input type="hidden" name="Type" value="@Model.Type" />
            <input type="hidden" name="CurrentStateId" value="@Model.CurrentStateId" />
            @if (Model.CurrentStates != null)
            {
                @for (int i = 0; i < Model.CurrentStates.Count; i++)
                {
                    <input type="hidden" name="CurrentStates[@i]" value="@Model.CurrentStates.ElementAt(i)" />
                }
            }
            <input type="hidden" name="Position" value="@Model.Position" />
            <input type="hidden" name="IsAccepted" value="@Model.IsAccepted" />
            <input type="hidden" name="StateHistorySerialized" value="@Model.StateHistorySerialized" />
            <input type="hidden" name="IsCustomAutomaton" value="@Model.IsCustomAutomaton.ToString().ToLower()" />
            <input type="hidden" name="HasExecuted" value="@Model.HasExecuted" />
            <div class="btn-group" role="group">
                @{
                    bool hasInput = !string.IsNullOrEmpty(Model.Input);
                    bool isAtFirstPosition = Model.Position == 0;
                    bool isAtEnd = hasInput && Model.Position >= Model.Input.Length;
                    bool hasExecutionStarted = Model.HasExecuted || Model.Result != null || (Model.Type != AutomatonType.DFA && Model.CurrentStates != null && Model.CurrentStates.Any());
                    bool isInputValid = true;
                    if (hasInput && Model.Alphabet != null && Model.Alphabet.Any())
                    {
                        isInputValid = Model.Input.All(c => Model.Alphabet.Contains(c));
                    }
                    // Permit step forward even after a rejection when user stepped back
                    bool canStepForward = hasInput && isInputValid && !isAtEnd; 
                    bool canExecuteAll = hasInput && isInputValid && !isAtEnd; 
                    bool canStepBackward = !isAtFirstPosition && isInputValid;
                    bool canBackToStart = hasExecutionStarted && isInputValid && !isAtFirstPosition;
                    bool canReset = hasExecutionStarted;
                }
                <button type="submit" class="btn btn-primary @(!canStepForward ? "disabled" : "")" 
                        formaction="/Automaton/StepForward" @(!canStepForward ? "disabled" : "")
                        title="@(!canStepForward ? (!hasInput ? "Enter input to start stepping" : !isInputValid ? "Input contains invalid characters" : "Already at end of input") : "Process next symbol")">
                    <i class="fas fa-step-forward"></i> Step Forward
                </button>
                <button type="submit" class="btn btn-secondary @(!canStepBackward ? "disabled" : "")" 
                        formaction="/Automaton/StepBackward" @(!canStepBackward ? "disabled" : "")
                        title="@(!canStepBackward ? (!isInputValid ? "Input contains invalid characters" : "Already at first position") : "Undo last step")">
                    <i class="fas fa-step-backward"></i> Step Backward
                </button>
                <button type="submit" class="btn btn-success @(!canExecuteAll ? "disabled" : "")" 
                        formaction="/Automaton/ExecuteAll" @(!canExecuteAll ? "disabled" : "")
                        title="@(!canExecuteAll ? (!hasInput ? "Enter input to execute" : !isInputValid ? "Input contains invalid characters" : "Already at end of input") : "Run entire input at once")">
                    <i class="fas fa-play"></i> Execute All
                </button>
                <button type="submit" class="btn btn-warning @(!canBackToStart ? "disabled" : "")" 
                        formaction="/Automaton/BackToStart" @(!canBackToStart ? "disabled" : "")
                        title="@(!canBackToStart ? (!isInputValid ? "Input contains invalid characters" : "Already at start position") : "Reset to beginning of input")">
                    <i class="fas fa-home"></i> Back To Start
                </button>
                <button type="submit" class="btn btn-danger @(!canReset ? "disabled" : "")" 
                        formaction="/Automaton/Reset" @(!canReset ? "disabled" : "")
                        title="@(!canReset ? "Start execution to enable reset" : "Clear input and reset execution state")">
                    <i class="fas fa-refresh"></i> Reset
                </button>
            </div>
        </form>
    </div>
</div>

@if (Model.Result != null)
{
    <div class="alert @(Model.Result.Value ? "alert-success" : "alert-danger") mt-3">
        <strong>Result:</strong> 
        <i class="fas @(Model.Result.Value ? "fa-check-circle" : "fa-times-circle")"></i>
        @(Model.Result.Value ? "Accepted" : "Rejected")
        @if (Model.Type != AutomatonType.DFA && Model.CurrentStates != null && Model.CurrentStates.Any())
        {
            <small class="d-block mt-1">Final states: @Model.CurrentStatesDisplay</small>
        }
    </div>
}

@section Scripts {
    <style>
        /* Custom styling for readonly (formerly disabled) input during execution */
        .form-control.disabled { background-color: #f8f9fa; color: #6c757d; border-color: #dee2e6; cursor: not-allowed; }
        
        .input-lock-message { border-left: 3px solid #FFC107; padding-left: 8px; margin-top: 5px; }
        
        .input-lock-message i { color: #FFC107; }

        /* visualization styles (already present in file previously) */
        @@keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
        }
        
        .input-visualization {
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            border: 2px solid #dee2e6;
            border-radius: 8px;
            transition: border-color 0.3s ease;
            display: inline-block;
            min-height: 36px;
            width: 100%;
        }
        
        .input-visualization:hover {
            border-color: #adb5bd;
        }
        
        .input-visualization span { display: inline-block; margin: 2px 4px; padding: 4px 8px; border-radius: 4px; }
        
        .input-highlight-current {
            background: linear-gradient(145deg, #ffc107, #ffb300) !important;
            color: #212529 !important;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0 1px;
            box-shadow: 0 2px 4px rgba(255, 193, 7, 0.3);
        }
        
        .input-highlight-eof {
            background: linear-gradient(145deg, #17a2b8, #138496) !important;
            color: white !important;
            font-weight: 600;
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0 2px;
            box-shadow: 0 2px 4px rgba(23, 162, 184, 0.3);
        }
        
        .input-highlight-processed {
            color: #6c757d;
            opacity: 0.7;
            transition: opacity 0.3s ease;
            background: transparent;
        }
        
        .input-visualization:hover .input-highlight-processed {
            opacity: 1;
        }
        
        .position-badge {
            animation: fadeIn 0.5s ease-in;
        }
        
        @@keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
    <script>
        // Serialize alphabet safely for JS usage
        const alphabet = @Html.Raw(System.Text.Json.JsonSerializer.Serialize((Model.Alphabet ?? new List<char>()).Where(c => c != 'ε').Select(c => c.ToString()).ToList()));
        // Serialize states and transitions for generating accepting strings
        const jsStates = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.States != null ? Model.States.Select(s => new { Id = s.Id, IsStart = s.IsStart, IsAccepting = s.IsAccepting }) : System.Linq.Enumerable.Empty<object>()));
        const jsTransitions = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.Transitions != null ? Model.Transitions.Select(t => new { From = t.FromStateId, To = t.ToStateId, Symbol = t.Symbol == '\0' ? null : t.Symbol.ToString() }) : System.Linq.Enumerable.Empty<object>()));

        function isInputAllowedByAlphabet(input) {
            if (!input) return true; // empty string is allowed
            for (let ch of input) { if (!alphabet.includes(ch)) return false; }
            return true;
        }

        document.getElementById('inputString').addEventListener('input', function() {
            const input = this.value; let isValid = isInputAllowedByAlphabet(input);
            this.className = (this.className.replace(/\b(is-valid|is-invalid)\b/g, '').trim() + ' ' + (isValid ? 'is-valid' : 'is-invalid')).trim();
            updateButtonStates(input, isValid);
            renderInputVisualization(input, 0); // position is 0 while editing
        });

        function applySuggestion(value) {
            const field = document.getElementById('inputString');
            // empty string should clear the input
            field.value = value || '';
            field.dispatchEvent(new Event('input'));
        }

        document.getElementById('randomSuggestion').addEventListener('click', function() {
            const minLen = 1, maxLen = 8;
            const len = Math.floor(Math.random() * (maxLen - minLen + 1)) + minLen;
            let out = '';
            if (alphabet.length === 0) { out = ''; }
            else {
                for (let i = 0; i < len; i++) {
                    out += alphabet[Math.floor(Math.random() * alphabet.length)];
                }
            }
            applySuggestion(out);
        });

        // Generate accepting string using BFS (shortest by symbol count), up to maxLen
        // Collect accepting strings up to maxLen and provide varied outputs on repeated clicks
        let _acceptingCache = null; // array of strings
        let _acceptingIndex = 0;

        function collectAcceptingStrings(maxLen = 8, limit = 1000) {
            const starts = jsStates.filter(s => s.IsStart).map(s => s.Id);
            const acceptingSet = new Set(jsStates.filter(s => s.IsAccepting).map(s => s.Id));
            if (!starts || starts.length === 0) return [];
            const map = new Map();
            for (const t of jsTransitions) {
                if (!map.has(t.From)) map.set(t.From, []);
                map.get(t.From).push({ to: t.To, symbol: t.Symbol });
            }

            const results = new Set();
            const queue = [];
            const visited = new Set();
            for (const s of starts) queue.push({ state: s, str: '' });

            while (queue.length && results.size < limit) {
                const node = queue.shift();
                const key = node.state + '|' + node.str;
                if (visited.has(key)) continue;
                visited.add(key);

                if (acceptingSet.has(node.state)) {
                    results.add(node.str);
                }

                if (node.str.length >= maxLen) continue;

                const trans = map.get(node.state) || [];
                // epsilon transitions (symbol == null)
                for (const t of trans) {
                    if (t.symbol == null) {
                        queue.push({ state: t.to, str: node.str });
                    }
                }
                // non-epsilon transitions
                for (const t of trans) {
                    if (t.symbol != null) {
                        queue.push({ state: t.to, str: node.str + t.symbol });
                    }
                }

                if (visited.size > 20000) break; // safety
            }

            return Array.from(results);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        document.getElementById('generateAccepting').addEventListener('click', function() {
            const maxLen = 8;
            if (!_acceptingCache) {
                _acceptingCache = collectAcceptingStrings(maxLen, 1000);
                if (_acceptingCache.length === 0) {
                    alert('No accepting string found up to length ' + maxLen + '.');
                    return;
                }
                shuffle(_acceptingCache);
                _acceptingIndex = 0;
            }
            // If cache only has one element, regenerate with larger depth to try to get more
            if (_acceptingCache.length === 1) {
                const extended = collectAcceptingStrings(Math.max(12, maxLen * 2), 2000);
                if (extended.length > 1) {
                    _acceptingCache = extended;
                    shuffle(_acceptingCache);
                    _acceptingIndex = 0;
                }
            }

            if (_acceptingCache.length === 0) {
                alert('No accepting string available.');
                return;
            }

            const value = _acceptingCache[_acceptingIndex % _acceptingCache.length];
            _acceptingIndex = (_acceptingIndex + 1) % _acceptingCache.length;
            applySuggestion(value);
        });

        function updateButtonStates(inputValue, isInputValid) {
            const hasInput = !!inputValue; const position = @Model.Position; const isDfa = '@Model.Type' === 'DFA';
            const hasExecutionStarted = (@Model.HasExecuted.ToString().ToLower()) || @(Model.Result != null ? "true" : "false") || (!isDfa && (@(Model.CurrentStates != null && Model.CurrentStates.Any() ? "true" : "false")));
            const isAtEnd = hasInput && position >= inputValue.length;
            const stepForwardBtn = document.querySelector('button[formaction="/Automaton/StepForward"]');
            const stepBackwardBtn = document.querySelector('button[formaction="/Automaton/StepBackward"]');
            const executeAllBtn = document.querySelector('button[formaction="/Automaton/ExecuteAll"]');
            const backToStartBtn = document.querySelector('button[formaction="/Automaton/BackToStart"]');
            const resetBtn = document.querySelector('button[formaction="/Automaton/Reset"]');
            const inputField = document.getElementById('inputString');
            const canStepForward = hasInput && isInputValid && !isAtEnd;
            const canExecuteAll = hasInput && isInputValid && !isAtEnd;
            const canStepBackward = position > 0 && isInputValid;
            const canBackToStart = hasExecutionStarted && isInputValid && position > 0;
            const canReset = hasExecutionStarted;
            updateInputField(inputField, hasExecutionStarted);
            updateButton(stepForwardBtn, canStepForward, { enabled: 'Process next symbol', disabled: !hasInput ? 'Enter input to start stepping' : !isInputValid ? 'Input contains invalid characters' : 'Already at end of input' });
            updateButton(stepBackwardBtn, canStepBackward, { enabled: 'Undo last step', disabled: !isInputValid ? 'Input contains invalid characters' : 'Already at first position' });
            updateButton(executeAllBtn, canExecuteAll, { enabled: 'Run entire input at once', disabled: !hasInput ? 'Enter input to execute' : !isInputValid ? 'Input contains invalid characters' : 'Already at end of input' });
            updateButton(backToStartBtn, canBackToStart, { enabled: 'Reset to beginning of input', disabled: !isInputValid ? 'Input contains invalid characters' : 'Already at start position' });
            updateButton(resetBtn, canReset, { enabled: 'Clear input and reset execution state', disabled: 'Start execution to enable reset' });
        }

        function updateButton(button, on, titles) { if (on) { button.classList.remove('disabled'); button.removeAttribute('disabled'); button.title = titles.enabled; } else { button.classList.add('disabled'); button.setAttribute('disabled','disabled'); button.title = titles.disabled; } }

        function updateInputField(field, started) {
            if (started) { field.setAttribute('readonly','readonly'); field.classList.add('disabled'); field.placeholder='Input locked during execution - click Reset to enter new input'; let msg=field.parentElement.querySelector('.input-lock-message'); if(!msg){ msg=document.createElement('small'); msg.className='text-muted mt-1 d-block input-lock-message'; msg.innerHTML='<i class="fas fa-lock"></i> Input is locked during execution. Click <strong>Reset</strong> to enter a new word.'; field.parentElement.appendChild(msg);} }
            else { field.removeAttribute('readonly'); field.classList.remove('disabled'); field.placeholder='Enter a string using the alphabet above...'; let msg=field.parentElement.querySelector('.input-lock-message'); if(msg) msg.remove(); }
        }

        // Render per-character visualization into #inputVisualization
        function renderInputVisualization(value, position) {
            const container = document.getElementById('inputVisualization');
            if (!container) return;
            container.innerHTML = '';
            if (!value || value.length === 0) {
                const small = document.createElement('small'); small.className = 'text-muted'; small.textContent = 'No input provided'; container.appendChild(small); return;
            }
            for (let i = 0; i < value.length; i++) {
                const span = document.createElement('span');
                span.textContent = value[i];
                if (i < position) span.className = 'input-highlight-processed';
                else if (i === position) span.className = 'input-highlight-current';
                container.appendChild(span);
            }
            if (position >= value.length) {
                const eof = document.createElement('span'); eof.className = 'input-highlight-eof'; eof.textContent = '▮'; container.appendChild(eof);
            }
        }

        document.addEventListener('DOMContentLoaded', function(){ const field=document.getElementById('inputString'); const input=field.value; let valid=true; for(let ch of input){ if(!isInputAllowedByAlphabet(ch)){ valid=false; break; } } field.className=(field.className.replace(/\b(is-valid|is-invalid)\b/g,'').trim() + (input?(' '+(valid?'is-valid':'is-invalid')):'')); updateButtonStates(input, valid); renderInputVisualization(input, @Model.Position); });
    </script>
}

